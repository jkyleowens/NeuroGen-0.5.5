// ============================================================================
// AUTONOMOUS LEARNING AGENT IMPLEMENTATION
// File: src/AutonomousLearningAgent.cpp
// ============================================================================

#include <NeuroGen/AutonomousLearningAgent.h>
#include <NeuroGen/ControllerModule.h>
#include <NeuroGen/Network.h>
#include <NeuroGen/NetworkConfig.h>
#include <NeuroGen/EnhancedNeuralModule.h>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <sstream>
#include <random>
#include <iomanip>

// ============================================================================
// UTILITY FUNCTION IMPLEMENTATIONS
// ============================================================================

std::string actionTypeToString(ActionType type) {
    switch (type) {
        case ActionType::CLICK: return "CLICK";
        case ActionType::SCROLL: return "SCROLL";
        case ActionType::TYPE: return "TYPE";
        case ActionType::NAVIGATE: return "NAVIGATE";
        case ActionType::WAIT: return "WAIT";
        case ActionType::OBSERVE: return "OBSERVE";
        case ActionType::BACK: return "BACK";
        case ActionType::FORWARD: return "FORWARD";
        case ActionType::REFRESH: return "REFRESH";
        default: return "UNKNOWN";
    }
}

ActionType stringToActionType(const std::string& type_str) {
    if (type_str == "CLICK") return ActionType::CLICK;
    if (type_str == "SCROLL") return ActionType::SCROLL;
    if (type_str == "TYPE") return ActionType::TYPE;
    if (type_str == "NAVIGATE") return ActionType::NAVIGATE;
    if (type_str == "WAIT") return ActionType::WAIT;
    if (type_str == "OBSERVE") return ActionType::OBSERVE;
    if (type_str == "BACK") return ActionType::BACK;
    if (type_str == "FORWARD") return ActionType::FORWARD;
    if (type_str == "REFRESH") return ActionType::REFRESH;
    return ActionType::OBSERVE; // Default fallback
}

float computeBrowsingStateSimilarity(const BrowsingState& state1, const BrowsingState& state2) {
    float similarity = 0.0f;
    float weight_sum = 0.0f;
    
    // URL similarity (exact match or domain match)
    float url_weight = 0.3f;
    if (state1.current_url == state2.current_url) {
        similarity += url_weight * 1.0f;
    } else {
        // Extract domain and compare
        auto extractDomain = [](const std::string& url) {
            size_t start = url.find("://");
            if (start != std::string::npos) {
                start += 3;
                size_t end = url.find("/", start);
                return (end != std::string::npos) ? url.substr(start, end - start) : url.substr(start);
            }
            return url;
        };
        
        if (extractDomain(state1.current_url) == extractDomain(state2.current_url)) {
            similarity += url_weight * 0.5f;
        }
    }
    weight_sum += url_weight;
    
    // Visual features similarity
    float visual_weight = 0.4f;
    if (!state1.visual_features.empty() && !state2.visual_features.empty()) {
        float cosine_sim = 0.0f;
        float norm1 = 0.0f, norm2 = 0.0f;
        size_t min_size = std::min(state1.visual_features.size(), state2.visual_features.size());
        
        for (size_t i = 0; i < min_size; ++i) {
            cosine_sim += state1.visual_features[i] * state2.visual_features[i];
            norm1 += state1.visual_features[i] * state1.visual_features[i];
            norm2 += state2.visual_features[i] * state2.visual_features[i];
        }
        
        if (norm1 > 0 && norm2 > 0) {
            cosine_sim /= (std::sqrt(norm1) * std::sqrt(norm2));
            similarity += visual_weight * cosine_sim;
        }
    }
    weight_sum += visual_weight;
    
    // Structural similarity (page elements)
    float structural_weight = 0.3f;
    if (!state1.page_elements.empty() && !state2.page_elements.empty()) {
        size_t common_elements = 0;
        for (const auto& elem1 : state1.page_elements) {
            for (const auto& elem2 : state2.page_elements) {
                if (elem1 == elem2) {
                    common_elements++;
                    break;
                }
            }
        }
        float structural_sim = static_cast<float>(common_elements) / 
                             std::max(state1.page_elements.size(), state2.page_elements.size());
        similarity += structural_weight * structural_sim;
    }
    weight_sum += structural_weight;
    
    return weight_sum > 0 ? similarity / weight_sum : 0.0f;
}

// ============================================================================
// MEMORY SYSTEM HELPER CLASS
// ============================================================================

/**
 * @brief Memory system for the autonomous learning agent
 */
class MemorySystem {
public:
    // Episode storage and retrieval
    std::vector<MemoryTrace> episodic_memory_;
    std::map<std::string, std::vector<float>> semantic_memory_;
    
    // Memory management
    size_t max_episodes_;
    float consolidation_threshold_;
    
    MemorySystem(size_t max_episodes = 10000) 
        : max_episodes_(max_episodes), consolidation_threshold_(0.7f) {}
    
    void storeEpisode(const MemoryTrace& trace) {
        episodic_memory_.push_back(trace);
        
        // Maintain memory capacity
        if (episodic_memory_.size() > max_episodes_) {
            // Remove oldest memories with low importance
            auto it = std::min_element(episodic_memory_.begin(), episodic_memory_.end(),
                [](const MemoryTrace& a, const MemoryTrace& b) {
                    return a.importance_weight < b.importance_weight;
                });
            if (it != episodic_memory_.end() && it->importance_weight < consolidation_threshold_) {
                episodic_memory_.erase(it);
            }
        }
    }
    
    std::vector<MemoryTrace> retrieveSimilarEpisodes(
        const BrowsingState& current_state, size_t max_results = 10) {
        std::vector<std::pair<float, MemoryTrace*>> similarities;
        
        // Extract features from current state for comparison
        std::vector<float> current_features = extractStateFeatures(current_state);
        
        for (auto& episode : episodic_memory_) {
            float similarity = computeCosineSimilarity(current_features, episode.state_vector);
            similarities.emplace_back(similarity, &episode);
        }
        
        // Sort by similarity and return top results
        std::sort(similarities.begin(), similarities.end(),
            [](const auto& a, const auto& b) { return a.first > b.first; });
        
        std::vector<MemoryTrace> results;
        size_t count = std::min(max_results, similarities.size());
        for (size_t i = 0; i < count; ++i) {
            results.push_back(*similarities[i].second);
        }
        
        return results;
    }
    
private:
    std::vector<float> extractStateFeatures(const BrowsingState& state) {
        std::vector<float> features;
        
        // URL features (simple hash-based encoding)
        features.push_back(static_cast<float>(std::hash<std::string>{}(state.current_url) % 1000) / 1000.0f);
        
        // Page element features
        features.push_back(static_cast<float>(state.page_elements.size()) / 100.0f);
        
        // Scroll position feature
        features.push_back(static_cast<float>(state.scroll_position) / 10000.0f);
        
        // Window dimensions
        features.push_back(static_cast<float>(state.window_width) / 2000.0f);
        features.push_back(static_cast<float>(state.window_height) / 2000.0f);
        
        // Loading state
        features.push_back(state.page_loading ? 1.0f : 0.0f);
        
        return features;
    }
    
    float computeCosineSimilarity(const std::vector<float>& a, const std::vector<float>& b) {
        if (a.size() != b.size()) return 0.0f;
        
        float dot_product = 0.0f;
        float norm_a = 0.0f;
        float norm_b = 0.0f;
        
        for (size_t i = 0; i < a.size(); ++i) {
            dot_product += a[i] * b[i];
            norm_a += a[i] * a[i];
            norm_b += b[i] * b[i];
        }
        
        if (norm_a == 0.0f || norm_b == 0.0f) return 0.0f;
        
        return dot_product / (std::sqrt(norm_a) * std::sqrt(norm_b));
    }
};

// ============================================================================
// AUTONOMOUS LEARNING AGENT IMPLEMENTATION
// ============================================================================

AutonomousLearningAgent::AutonomousLearningAgent(const NetworkConfig& config) 
    : config_(config), autonomous_learning_active_(false), exploration_rate_(0.1f), learning_progress_(0.0f) {
    // Initialize performance stats
    performance_stats_ = PerformanceStats();
    
    // Reserve space for experiences
    recent_experiences_.reserve(1000);
}

bool AutonomousLearningAgent::initialize() {
    std::cout << "🧠 Initializing Autonomous Learning Agent..." << std::endl;
    
    // Initialize specialized modules
    if (!initializeSpecializedModules()) {
        std::cerr << "❌ Failed to initialize specialized modules" << std::endl;
        return false;
    }
    
    std::cout << "✅ Autonomous Learning Agent initialized successfully" << std::endl;
    return true;
}

void AutonomousLearningAgent::update(float dt) {
    // Update all specialized modules
    for (auto& [name, module] : specialized_modules_) {
        if (module && module->isActive()) {
            module->update(dt);
        }
    }
    
    // Update learning progress
    updateLearningProgress();
}

void AutonomousLearningAgent::shutdown() {
    std::cout << "🔄 Shutting down Autonomous Learning Agent..." << std::endl;
    
    autonomous_learning_active_ = false;
    specialized_modules_.clear();
    
    std::cout << "✅ Autonomous Learning Agent shutdown complete" << std::endl;
}

std::vector<float> AutonomousLearningAgent::collect_inter_module_signals(const std::string& target_module) {
    // Simple implementation - collect signals from all modules for the target
    std::vector<float> combined_signals;
    
    for (const auto& [name, module] : specialized_modules_) {
        if (name != target_module && module && module->isActive()) {
            // Get output from this module
            auto outputs = module->getOutputs();
            combined_signals.insert(combined_signals.end(), outputs.begin(), outputs.end());
        }
    }
    
    return combined_signals;
}

void AutonomousLearningAgent::distribute_module_output(const std::string& source_module, 
                                                      const std::vector<float>& output) {
    // Distribute output to all other active modules
    for (auto& [name, module] : specialized_modules_) {
        if (name != source_module && module && module->isActive()) {
            // Send signal to this module
            module->receiveInterModuleSignal(output, source_module);
        }
    }
}

std::vector<BrowsingAction> AutonomousLearningAgent::generate_action_candidates() {
    std::vector<BrowsingAction> candidates;
    
    // Generate basic action candidates
    BrowsingAction wait_action;
    wait_action.type = ActionType::WAIT;
    wait_action.confidence = 0.9f;
    wait_action.expected_reward = 0.1f;
    candidates.push_back(wait_action);
    
    BrowsingAction observe_action;
    observe_action.type = ActionType::OBSERVE;
    observe_action.confidence = 0.8f;
    observe_action.expected_reward = 0.2f;
    candidates.push_back(observe_action);
    
    BrowsingAction scroll_action;
    scroll_action.type = ActionType::SCROLL;
    scroll_action.scroll_amount = 100;
    scroll_action.confidence = 0.7f;
    scroll_action.expected_reward = 0.3f;
    candidates.push_back(scroll_action);
    
    return candidates;
}

BrowsingAction AutonomousLearningAgent::selectBestAction(const std::vector<BrowsingAction>& candidates) {
    if (candidates.empty()) {
        // Return default wait action
        BrowsingAction default_action;
        default_action.type = ActionType::WAIT;
        return default_action;
    }
    
    // Simple selection based on expected reward and confidence
    auto best_it = std::max_element(candidates.begin(), candidates.end(),
        [](const BrowsingAction& a, const BrowsingAction& b) {
            return (a.expected_reward * a.confidence) < (b.expected_reward * b.confidence);
        });
    
    return *best_it;
}

void AutonomousLearningAgent::startAutonomousLearning() {
    autonomous_learning_active_ = true;
    std::cout << "🚀 Autonomous learning started" << std::endl;
}

void AutonomousLearningAgent::stopAutonomousLearning() {
    autonomous_learning_active_ = false;
    std::cout << "⏹️ Autonomous learning stopped" << std::endl;
}

float AutonomousLearningAgent::autonomousLearningStep(float dt) {
    if (!autonomous_learning_active_) {
        return learning_progress_;
    }
    
    // Update modules
    update(dt);
    
    // Increment action count
    performance_stats_.total_actions_taken += 1.0f;
    
    // Update exploration rate based on performance
    if (performance_stats_.total_actions_taken > 0) {
        float success_rate = performance_stats_.successful_actions / performance_stats_.total_actions_taken;
        if (success_rate < 0.5f) {
            exploration_rate_ = std::min(0.3f, exploration_rate_ + 0.01f);
        } else {
            exploration_rate_ = std::max(0.05f, exploration_rate_ - 0.005f);
        }
    }
    
    // Update learning progress
    learning_progress_ = std::min(1.0f, learning_progress_ + 0.001f);
    
    return learning_progress_;
}

void AutonomousLearningAgent::addLearningGoal(std::unique_ptr<AutonomousGoal> goal) {
    learning_goals_.push_back(std::move(goal));
}

void AutonomousLearningAgent::setEnvironmentSensor(std::function<BrowsingState()> sensor) {
    environment_sensor_ = sensor;
}

void AutonomousLearningAgent::setActionExecutor(std::function<float(const BrowsingAction&)> executor) {
    action_executor_ = executor;
}

std::vector<float> AutonomousLearningAgent::processEnvironmentalState(const BrowsingState& state) {
    std::vector<float> processed_state;
    
    // Basic state processing
    processed_state.push_back(static_cast<float>(state.scroll_position) / 10000.0f);
    processed_state.push_back(static_cast<float>(state.window_width) / 2000.0f);
    processed_state.push_back(static_cast<float>(state.window_height) / 2000.0f);
    processed_state.push_back(state.page_loading ? 1.0f : 0.0f);
    processed_state.push_back(static_cast<float>(state.page_elements.size()) / 100.0f);
    
    return processed_state;
}

PerformanceStats AutonomousLearningAgent::getPerformanceMetrics() const {
    return performance_stats_;
}

std::map<std::string, float> AutonomousLearningAgent::getNetworkStatistics() const {
    std::map<std::string, float> stats;
    
    // Count total neurons and synapses across all modules
    float total_neurons = 0.0f;
    float total_synapses = 0.0f;
    float total_activity = 0.0f;
    
    for (const auto& [name, module] : specialized_modules_) {
        if (module) {
            auto module_metrics = module->getPerformanceMetrics();
            total_neurons += module_metrics["neuron_count"];
            total_activity += module_metrics["average_activity"];
        }
    }
    
    stats["neuron_count"] = total_neurons;
    stats["synapse_count"] = total_synapses;
    stats["average_activity"] = total_activity / specialized_modules_.size();
    stats["module_count"] = static_cast<float>(specialized_modules_.size());
    
    return stats;
}

std::map<std::string, float> AutonomousLearningAgent::getGoalCompetencies() const {
    std::map<std::string, float> competencies;
    
    for (const auto& goal : learning_goals_) {
        // Simple competency calculation
        float competency = std::min(1.0f, learning_progress_ * (goal->priority / 10.0f));
        competencies[goal->description] = competency;
    }
    
    return competencies;
}

float AutonomousLearningAgent::getExplorationEffectiveness() const {
    return exploration_rate_;
}

std::string AutonomousLearningAgent::generateLearningReport() const {
    std::ostringstream report;
    
    report << "🧠 Autonomous Learning Agent Report\n";
    report << "===================================\n\n";
    
    // Performance metrics
    report << "📊 Performance Metrics:\n";
    report << "  Total Actions: " << performance_stats_.total_actions_taken << "\n";
    report << "  Successful Actions: " << performance_stats_.successful_actions << "\n";
    report << "  Success Rate: " << std::fixed << std::setprecision(2) 
           << (performance_stats_.total_actions_taken > 0 ? 
               performance_stats_.successful_actions / performance_stats_.total_actions_taken * 100 : 0) << "%\n";
    report << "  Average Reward: " << performance_stats_.average_reward << "\n";
    report << "  Exploration Rate: " << exploration_rate_ << "\n\n";
    
    // Network statistics
    auto network_stats = getNetworkStatistics();
    report << "🧮 Network Statistics:\n";
    report << "  Modules: " << network_stats["module_count"] << "\n";
    report << "  Neurons: " << network_stats["neuron_count"] << "\n";
    report << "  Average Activity: " << network_stats["average_activity"] << "\n\n";
    
    // Goal competencies
    auto competencies = getGoalCompetencies();
    report << "🎯 Goal Competencies:\n";
    for (const auto& [goal, competency] : competencies) {
        report << "  " << goal << ": " << std::setprecision(1) << competency * 100 << "%\n";
    }
    
    report << "\n📈 Overall Learning Progress: " << std::setprecision(1) << learning_progress_ * 100 << "%\n";
    
    return report.str();
}

void AutonomousLearningAgent::storeExperience(const BrowsingState& state, const BrowsingAction& action, float reward) {
    MemoryTrace trace;
    trace.state_vector = processEnvironmentalState(state);
    trace.reward_received = reward;
    trace.importance_weight = std::abs(reward) + 0.1f; // Higher importance for high-magnitude rewards
    trace.timestamp = std::chrono::steady_clock::now();
    
    recent_experiences_.push_back(trace);
    
    // Maintain experience buffer size
    if (recent_experiences_.size() > 1000) {
        recent_experiences_.erase(recent_experiences_.begin());
    }
}

bool AutonomousLearningAgent::initializeSpecializedModules() {
    try {
        // Create basic modules for demonstration
        auto visual_module = std::make_shared<EnhancedNeuralModule>("visual_cortex", config_);
        auto memory_module = std::make_shared<EnhancedNeuralModule>("memory_system", config_);
        auto decision_module = std::make_shared<EnhancedNeuralModule>("decision_maker", config_);
        
        if (!visual_module->initialize() || !memory_module->initialize() || !decision_module->initialize()) {
            return false;
        }
        
        specialized_modules_["visual_cortex"] = visual_module;
        specialized_modules_["memory_system"] = memory_module;
        specialized_modules_["decision_maker"] = decision_module;
        
        std::cout << "✅ Initialized " << specialized_modules_.size() << " specialized modules" << std::endl;
        return true;
        
    } catch (const std::exception& e) {
        std::cerr << "❌ Exception during module initialization: " << e.what() << std::endl;
        return false;
    }
}

void AutonomousLearningAgent::updateLearningProgress() {
    // Simple learning progress calculation based on recent performance
    if (performance_stats_.total_actions_taken > 10) {
        float recent_success_rate = performance_stats_.successful_actions / performance_stats_.total_actions_taken;
        learning_progress_ = std::max(learning_progress_, recent_success_rate);
    }
    
    // Gradual progress increase
    learning_progress_ = std::min(1.0f, learning_progress_ + 0.0001f);
}